<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>3. Mapping Domain Classes to Mongo Collections</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="3. Mapping Domain Classes to Mongo Collections">3. Mapping Domain Classes to Mongo Collections</a></h1>The way GORM for Mongo works is to map each domain class to a Mongo collection. For example given a domain class such as:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;object">String</span> lastName
  <span class="java&#45;keyword">static</span> hasMany = &#91;pets:Pet&#93;
&#125;</pre></div><p class="paragraph"/>This will map onto a Mongo <a href="http://api.mongodb.org/java/current/com/mongodb/DBCollection.html" target="blank">DBCollection</a> called "person".<p class="paragraph"/>It is quite common in Mongo to embed documents within documents (nested documents). This can be done with GORM embedded types:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> firstName
  <span class="java&#45;object">String</span> lastName
  Address address
  <span class="java&#45;keyword">static</span> embedded = &#91;'address'&#93;
&#125;</pre></div><p class="paragraph"/>You can also map lists and maps of basic types (such as strings) simply by defining the appropriate collection type:<p class="paragraph"/><div class="code"><pre>class Person &#123;
	List&#60;<span class="java&#45;object">String</span>&#62; friends
	Map pets
&#125;<p class="paragraph"/>...<p class="paragraph"/><span class="java&#45;keyword">new</span> Person(friends:&#91;'Fred', 'Bob'&#93;, pets:&#91;chuck:<span class="java&#45;quote">"Dog"</span>, eddie:'Parrot'&#93;).save(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>Basic collection types are stored as native ArrayList and BSON documents within the Mongo documents.<p class="paragraph"/>You may wish to customize how a domain class maps onto a <code>DBCollection</code>. This is possible using the <code>mapping</code> block as follows:<p class="paragraph"/><div class="code"><pre>class Person &#123;
   ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
    collection <span class="java&#45;quote">"mycollection"</span>
    database <span class="java&#45;quote">"mydb"</span>
  &#125;
&#125;</pre></div><p class="paragraph"/>In this example we see that the <code>Person</code> entity has been mapped to a collection called "mycollection" in a database called "mydb".<p class="paragraph"/>You can also control how an individual property maps onto a Mongo Document field (the default is to use the property name itself):<p class="paragraph"/><div class="code"><pre>class Person &#123;
   ..
  <span class="java&#45;keyword">static</span> mapping = &#123;
	firstName field:<span class="java&#45;quote">"first_name"</span>
  &#125;
&#125;</pre></div><p class="paragraph"/><h2><a name="3.1 Identity Generation">3.1 Identity Generation</a></h2>By default in GORM entities are supplied with an integer-based identifier. So for example the following entity:<p class="paragraph"/><div class="code"><pre>class Person &#123;&#125;</pre></div><p class="paragraph"/>Has a property called <code>id</code> of type <code>java.lang.Long</code>. In this case GORM for Mongo will generate a sequence based identifier using the technique <a href="http://www.mongodb.org/display/DOCS/Atomic+Operations" target="blank">described in the Mongo documentation</a> on Atomic operations.<p class="paragraph"/>However, sequence based integer identifiers are not ideal for environments that require <a href="http://www.mongodb.org/display/DOCS/Sharding" target="blank">sharding</a> (one of the nicer features of Mongo). Hence it is generally advised to use either String based ids:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    <span class="java&#45;object">String</span> id
&#125;</pre></div><p class="paragraph"/>Or a native BSON <a href="http://api.mongodb.org/java/current/org/bson/types/ObjectId.html" target="blank">ObjectId</a>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span>  org.bson.types.ObjectId<p class="paragraph"/>class Person &#123;
    ObjectId id
&#125;</pre></div><p class="paragraph"/>BSON <code>ObjectId</code> instances are generated in a similar fashion to <code>UUIDs</code>.<h2><a name="3.2 Indexing Queries">3.2 Indexing Queries</a></h2>Mongo doesn't require that you specify indices to query, but like a relational database without specifying indices your queries will be significantly slower.<p class="paragraph"/>With that in mind it is important to specify the properties you plan to query using the mapping block:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> name
  <span class="java&#45;keyword">static</span> mapping = &#123;
    name index:<span class="java&#45;keyword">true</span>
  &#125;
&#125;</pre></div><p class="paragraph"/>With the above mapping a Mongo index will be automatically created for you. You can customize the index options using the <code>indexAttributes</code> configuration parameter:<p class="paragraph"/><div class="code"><pre>class Person &#123;
  <span class="java&#45;object">String</span> name
  <span class="java&#45;keyword">static</span> mapping = &#123;
    name index:<span class="java&#45;keyword">true</span>, indexAttributes: &#91;unique:<span class="java&#45;keyword">true</span>, dropDups:<span class="java&#45;keyword">true</span>&#93;
  &#125;
&#125;</pre></div>
<h2><a name="3.3 Customizing the WriteConcern">3.3 Customizing the WriteConcern</a></h2>A feature of Mongo is its ability to customize how important a database write is to the user. The Java client models this as a <a href="http://api.mongodb.org/java/current/com/mongodb/WriteConcern.html" target="blank">WriteConcern</a> and there are various options that indicate whether the client cares about server or network errors, or whether the data has been successfully written or not.<p class="paragraph"/>If you wish to customize the <code>WriteConcern</code> for a domain class you can do so in the mapping block:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> com.mongodb.WriteConcern<p class="paragraph"/>class Person &#123;
  <span class="java&#45;object">String</span> name
  <span class="java&#45;keyword">static</span> mapping = &#123;
    writeConcern WriteConcern.FSYNC_SAFE	
  &#125;	
&#125;</pre></div><h2><a name="3.4 Dynamic Attributes">3.4 Dynamic Attributes</a></h2>Unlike a relational database, Mongo allows for "schemaless" persistence where there are no limits to the number of attributes a particular document can have. A GORM domain class on the other hand has a schema in that there are a fixed number of properties. For example consider the following domain class:<p class="paragraph"/><div class="code"><pre>class Plant &#123;
    <span class="java&#45;object">boolean</span> goesInPatch
    <span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/>Here there are two fixed properties, <code>name</code> and <code>goesInPatch</code>, that will be persisted into the Mongo document. Using GORM for Mongo you can however use dynamic properties via the Groovy subscript operator. For example:<p class="paragraph"/><div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Plant(name:<span class="java&#45;quote">"Pineapple"</span>)
p&#91;'color'&#93; = 'Yellow'
p&#91;'hasLeaves'&#93; = <span class="java&#45;keyword">true</span>
p.save()<p class="paragraph"/>p = Plant.findByName(<span class="java&#45;quote">"Pineapple"</span>)<p class="paragraph"/>println p&#91;'color'&#93;
println p&#91;'hasLeaves'&#93;</pre></div><p class="paragraph"/>Using the subscript operator you can add additional attributes to the underlying <code>DBObject</code> instance that gets persisted to the Mongo allowing for more dynamic domain models.<h2><a name="3.5 Geospacial Querying">3.5 Geospacial Querying</a></h2>It is possible to use Mongo's <a href="http://www.mongodb.org/display/DOCS/Geospatial+Indexing" target="blank">Geospacial querying</a> capability by mapping a list or map property using the <code>geoIndex</code> mapping:<p class="paragraph"/><div class="code"><pre>class Hotel &#123;
	<span class="java&#45;object">String</span> name
	List location<p class="paragraph"/>	<span class="java&#45;keyword">static</span> mapping = &#123;
		location geoIndex:<span class="java&#45;keyword">true</span>
	&#125;
&#125;</pre></div><p class="paragraph"/>By default the index creation assumes latitude/longitude and thus is configured for a -180..180 range. If you are indexing something else you can customise this with <code>indexAttributes</code><p class="paragraph"/><div class="code"><pre>class Hotel &#123;
	<span class="java&#45;object">String</span> name
	List location<p class="paragraph"/>	<span class="java&#45;keyword">static</span> mapping = &#123;
		location geoIndex:<span class="java&#45;keyword">true</span>, indexAttributes:&#91;min:&#45;500, max:500&#93;
	&#125;
&#125;</pre></div><p class="paragraph"/>You can then save Geo locations using a two dimensional list:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Hotel(name:<span class="java&#45;quote">"Hilton"</span>, location:&#91;50, 50&#93;).save()</pre></div><p class="paragraph"/>Alternatively you can use a map with keys representing latitude and longitude:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Hotel(name:<span class="java&#45;quote">"Hilton"</span>, location:&#91;lat: 40.739037, <span class="java&#45;object">long</span>: 73.992964&#93;).save()</pre></div><p class="paragraph"/>Once you have your data indexed you can use Mongo specific dynamic finders to find hotels near a given a location:<p class="paragraph"/><div class="code"><pre>def h = Hotel.findByLocationNear(&#91;50, 60&#93;)
assert h.name == 'Hilton'</pre></div><p class="paragraph"/>You can also find a location within a box (bound queries). Boxes are defined by specifying the lower-left and upper-right corners:<p class="paragraph"/><div class="code"><pre>def box = &#91;&#91;40.73083, &#45;73.99756&#93;, &#91;40.741404,  &#45;73.988135&#93;&#93;
def h = Hotel.findByLocationWithinBox(box)</pre></div><p class="paragraph"/>You can also find a location within a circle. Circles are specified using a center and radius:<p class="paragraph"/><div class="code"><pre>def center = &#91;50, 50&#93;
def radius = 10
def h = Hotel.findByLocationWithinCircle(&#91;center, radius&#93;)</pre></div><p class="paragraph"/>If you plan on querying a location and some other value it is recommended to use a compound index:<p class="paragraph"/><div class="code"><pre>class Hotel &#123;
	<span class="java&#45;object">String</span> name
	List location
	<span class="java&#45;object">int</span> stars<p class="paragraph"/>	<span class="java&#45;keyword">static</span> mapping = &#123;
		compoundIndex location:<span class="java&#45;quote">"2d"</span>, stars:1
	&#125;
&#125;</pre></div><p class="paragraph"/>In the example above you an index is created for both the location and the number of stars a <code>Hotel</code> has.

    </body>
</html>
