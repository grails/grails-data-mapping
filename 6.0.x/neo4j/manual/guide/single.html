<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <title>GORM for Neo4j 6.0.0.M1</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="../guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#gettingStarted"><strong>2</strong><span>Getting Started</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#mapping"><strong>3</strong><span>Mapping domain classes to Neo4j node space</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#querying"><strong>4</strong><span>Querying with GORM for Neo4j</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#neo4jEnhancements"><strong>5</strong><span>Enhancements to Neo4j core API</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                
            </div>
            <p></p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>GORM for Neo4j - Reference Documentation</h1>
                            <p><strong>Authors:</strong> Stefan Armbruster, Graeme Rocher</p>
                            <p><strong>Version:</strong> 6.0.0.M1</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#compatibility"><strong>1.1</strong><span>Compatibility with GORM for Hibernate</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#releaseNotes"><strong>1.2</strong><span>Release Notes</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#gettingStarted"><strong>2</strong><span>Getting Started</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#usingNeo4jStandalone"><strong>2.1</strong><span>Using Neo4j Standalone</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#combiningNeo4jAndHibernate"><strong>2.2</strong><span>Combining Neo4j And Hibernate</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#advancedConfiguration"><strong>2.3</strong><span>Advanced Configuration</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#springBoot"><strong>2.4</strong><span>Using GORM in Spring Boot</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#standalone"><strong>2.5</strong><span>GORM for Neo4j without Grails</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#mapping"><strong>3</strong><span>Mapping domain classes to Neo4j node space</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#idGeneration"><strong>3.1</strong><span>Neo4j ID generators</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#associations"><strong>3.2</strong><span>Understanding Association Mapping</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#labelStrategy"><strong>3.3</strong><span>Customizing the Label Strategy</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#schemaless"><strong>3.4</strong><span>Dynamic Properties and Associations</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#querying"><strong>4</strong><span>Querying with GORM for Neo4j</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#lazyLoading"><strong>4.1</strong><span>Understanding Lazy Loading</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#cypher"><strong>4.2</strong><span>Querying with Cypher</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#indexing"><strong>4.3</strong><span>Defining the Query Index</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#neo4jEnhancements"><strong>5</strong><span>Enhancements to Neo4j core API</span></a></div>
                            
                            <div style="clear:both" ></div>
                        </div>
                        
                        

<h1 id="introduction">1 Introduction</h1>
<a href="http://www.neo4j.org" target="blank">Neo4j</a> a Graph database that fits nicely in a Grails application.<p class="paragraph"/>The goal of GORM for Neo4j is to provide a 'as-complete-as-possible' GORM implementation that maps domain classes and instances to the Neo4j nodespace. The following features are supported:
<ul class="star">
<li>Marshalling from Neo4j Nodes to Groovy types and back again</li>
<li>Support for GORM dynamic finders, criteria and named queries</li>
<li>Session-managed transactions</li>
<li>access to Neo4j's traversal capabilities</li>
<li>Access the Neo4j graph database in all flavours (Embedded, REST and HA)</li>
<li>Neo4j autoindexing</li>
</ul><p class="paragraph"/>


<h2 id="compatibility">1.1 Compatibility with GORM for Hibernate</h2>
This implementation tries to be as compatible as possible with GORM for Hibernate. In general you can refer to the <a href="http://grails.github.io/grails-doc/latest/guide/GORM.html" target="blank">GORM documentation</a> and the "Domain Classes" section of the <a href="http://grails.org/doc/latest/" target="blank">reference guide</a> (see the left nav) for usage information.<p class="paragraph"/>The following key features are supported by GORM for Neo4j:
<ul class="star">
<li>Simple persistence methods (save,delete etc)</li>
<li>Dynamic finders</li>
<li>Criteria queries</li>
<li>Named queries</li>
<li>Inheritance</li>
<li>Embedded types</li>
<li>Query by example</li>
<li>Many-to-many associations (these can be modelled with a mapping class)</li>
</ul><p class="paragraph"/>However, some features are not supported:
<ul class="star">
<li>HQL queries (however Cypher Queries are)</li>
<li>Composite primary keys</li>
<li>Any direct interaction with the Hibernate API</li>
<li>Custom Hibernate user types</li>
</ul><p class="paragraph"/>There may be other limitations not mentioned here so in general it shouldn't be expected that an application based on GORM for Hibernate will "just work" without some tweaking involved. Having said that, the large majority of common GORM functionality is supported.



<h2 id="releaseNotes">1.2 Release Notes</h2>
The following new features are available in this release.
<ul class="star">
<li>Support for Neo4j Neo4j 2.3.x or above</li>
<li>Ability to query using Cypher with the default GORM methods (find, findAll)</li>
<li>Robust Spring Transaction Management</li>
<li>Support for Lazy &#38; Eager Loading using OPTIONAL MATCH</li>
<li>Improved Performance</li>
<li>Dirty Checking Implementation</li>
</ul><p class="paragraph"/>If you are using an older version of the plugin, and looking to upgrade the following changes may impact you:
<ul class="star">
<li>Neo4j JDBC is no longer used and the corresponding CypherEngine interface was removed</li>
<li>Dynamic associations are disabled by default, you can re-enable them in your entity mapping</li>
</ul><p class="paragraph"/>


<h1 id="gettingStarted">2 Getting Started</h1>
To get started with GORM for Neo4j you need to install the plugin into a Grails application.<p class="paragraph"/>For Grails 3.x you need to edit your <code>build.gradle</code> file and add the plugin as a dependency:<p class="paragraph"/><div class="code"><pre>dependencies &#123;
	compile 'org.grails.plugins:neo4j:VERSION'
&#125;</pre></div><p class="paragraph"/>
To do so for Grails 2.x edit the <code>grails-app/conf/BuildConfig.groovy</code> file and add the following plugin definition, where <code>VERSION</code> is the version of the plugin you plan to use:<p class="paragraph"/>
<div class="code"><pre>plugins &#123;
    compile ':neo4j:VERSION'
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
GORM for Neo4j requires Grails 2.5.x or above and Neo4j 2.3.x or above
</blockquote><p class="paragraph"/>By default Neo4j will used as embedded database inside the JVM, the default directory for the Neo4j datastore is <code>data/neo4j</code>.<p class="paragraph"/>



<h2 id="usingNeo4jStandalone">2.1 Using Neo4j Standalone</h2>
If you plan to use Neo4j as your primary datastore then you need to remove the Hibernate plugin by editing your <code>BuildConfig</code> or <code>build.gradle</code> (dependending on the version of Grails) and removing the Hibernate plugin definition<p class="paragraph"/>With this done all domain classes in grails-app/domain will be persisted via Neo4j and not Hibernate. You can create a domain class by running the regular <code>create-domain-class</code> command:<p class="paragraph"/><div class="code"><pre>grails create&#45;domain&#45;class Person</pre></div><p class="paragraph"/>The <code>Person</code> domain class will automatically be a persistent entity that can be stored in Neo4j.



<h2 id="combiningNeo4jAndHibernate">2.2 Combining Neo4j And Hibernate</h2>
If you have both the Hibernate and Neo4j plugins installed then by default all classes in the <code>grails-app/domain</code>  directory will be persisted by Hibernate and not Neo4j. If you want to persist a particular domain class with Neo4j then you must use the <code>mapWith</code> property in the domain class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mapWith = <span class="java&#45;quote">"neo4j"</span></pre></div><p class="paragraph"/>


<h2 id="advancedConfiguration">2.3 Advanced Configuration</h2>
As mentioned the GORM for Neo4j plugin will configure all the defaults for you, but if you wish to customize those defaults you can do so in the your <code>grails-app/conf/DataSource.groovy</code> file or in the <code>grails-app/conf/application.groovy</code> file for Grails 3.x and above:<p class="paragraph"/><div class="code"><pre>grails &#123;
    neo4j &#123;
        type = <span class="java&#45;quote">"embedded"</span>
        location = <span class="java&#45;quote">"/<span class="java&#45;keyword">var</span>/neo4j"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>The <code>type</code> provides currently the following choices:<p class="paragraph"/><h4>type = "embedded"</h4><p class="paragraph"/>Runs Neo4j in embedded mode, Neo4j and Grails use the same JVM. No seperate setup outside the Grails application is required. <code>location</code> specifies the directory where Neo4j stores its data.<p class="paragraph"/>Example:
<div class="code"><pre>grails &#123;
    neo4j &#123;
        type = <span class="java&#45;quote">"embedded"</span>
        location = <span class="java&#45;quote">"/<span class="java&#45;keyword">var</span>/neo4j"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
If your configuration is empty, 'embedded' is used as default.
</blockquote><p class="paragraph"/><h4>type = "rest"</h4><p class="paragraph"/>Uses a <code>org.grails.datastore.gorm.neo4j.rest.GrailsCypherRestGraphDatabase</code> instance to connect to a Neo4j database. See <a href="http://neo4j.com/docs/stable/server-installation.html" target="blank">http://neo4j.com/docs/stable/server-installation.html</a> for how to setup a Neo4j server.<p class="paragraph"/><code>location</code> specifies the URL of he Neo4j REST server. When using the Heroku Neo4j addon, omit the location. In this case location will default to env.NEO4J_URL that is provided by Heroku.<p class="paragraph"/>Example:
<div class="code"><pre>grails &#123;
    neo4j &#123;
        type = <span class="java&#45;quote">"<span class="java&#45;keyword">rest</span>"</span>
        location = <span class="java&#45;quote">"http://localhost:7474/db/data/"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>Additionally you must add the following dependencies to your application's <code>build.gradle</code> or <code>grails-app/conf/BuildConfig.groovy</code> file:<p class="paragraph"/><div class="code"><pre>compile 'org.springframework.data:spring&#45;data&#45;neo4j:3.4.0.RELEASE'
compile 'org.springframework.data:spring&#45;data&#45;neo4j&#45;<span class="java&#45;keyword">rest</span>:3.4.0.RELEASE'
    exclude group:'org.neo4j.test', module:'neo4j&#45;harness'
&#125;</pre></div><p class="paragraph"/>GORM for Neo4j uses the REST implementation from the Spring Data Neo4j REST project.<p class="paragraph"/><h4>type = "ha"</h4><p class="paragraph"/>Uses a Neo4j HA setup, for details see <a href="http://neo4j.com/docs/stable/ha.html" target="blank">http://neo4j.com/docs/stable/ha.html</a>. In this case params must at least contain<p class="paragraph"/><blockquote class="note">
For Neo4j HA either a commercial license is <a href="http://neo4j.org/licensing-guide/" target="blank">required</a>, or you could use AGPL.
</blockquote><p class="paragraph"/>Example:
<div class="code"><pre>grails &#123;
    neo4j &#123;
        type = <span class="java&#45;quote">"ha"</span>
        location = <span class="java&#45;quote">"/<span class="java&#45;keyword">var</span>/neo4j"</span>
        // see http://neo4j.com/docs/stable/ha&#45;configuration.html
        options = &#91;
                'ha.server_id': 1,
                'ha.coordinators': 'localhost:2181,localhost:2182,localhost:2183'
        &#93;
    &#125;
&#125;</pre></div><p class="paragraph"/>Additionally you must add another dependency to your application's <code>build.gradle</code> or <code>grails-app/conf/BuildConfig.groovy</code>:<p class="paragraph"/><div class="code"><pre>compile 'org.neo4j:neo4j&#45;ha:$neo4jVersion'</pre></div><p class="paragraph"/><h4>type = "impermanent"</h4><p class="paragraph"/>Uses ImpermanentGraphDatabase which is good for testing and early stage development.<p class="paragraph"/>This option required a dependency to artifact group: "org.neo4j", name:"neo4j-kernel", version:neo4jVersion, classifier:'tests' in <code>build.gradle</code> or <code>BuildConfig.groovy</code>.<p class="paragraph"/><div class="code"><pre>compile group: <span class="java&#45;quote">"org.neo4j"</span>, name: <span class="java&#45;quote">"neo4j&#45;kernel"</span>, version: neo4jVersion, classifier: 'tests'</pre></div><p class="paragraph"/><blockquote class="note">
ImpermanentGraphDatabase is intended to be used for testing.
</blockquote><p class="paragraph"/><h4>custom graph database</h4><p class="paragraph"/>If you use a custom implementation of GraphDatabaseService, you can use
<div class="code"><pre>grails &#123;
    neo4j &#123;
        type = <span class="java&#45;quote">"my.fancy.custom.GraphDatabaseServiceImplementation"</span>
        location = <span class="java&#45;quote">"/<span class="java&#45;keyword">var</span>/neo4j"</span>
        options = &#91; :&#93;
    &#125;
&#125;</pre></div>



<h2 id="springBoot">2.4 Using GORM in Spring Boot</h2>
To use GORM for Neo4j in Spring Boot add the necessary dependencies to your Boot application:<p class="paragraph"/><div class="code"><pre>compile(<span class="java&#45;quote">"org.grails:gorm&#45;neo4j&#45;spring&#45;boot:VERSION"</span>)</pre></div><p class="paragraph"/>Ensure your Boot <code>Application</code> class is annotated with <code>ComponentScan</code>, example:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.springframework.boot.SpringApplication
<span class="java&#45;keyword">import</span> org.springframework.boot.autoconfigure.EnableAutoConfiguration
<span class="java&#45;keyword">import</span> org.springframework.context.annotation.&#42;<p class="paragraph"/>@Configuration
@EnableAutoConfiguration
@ComponentScan
class Application &#123;
    <span class="java&#45;keyword">static</span> void main(<span class="java&#45;object">String</span>&#91;&#93; args) &#123;
        SpringApplication.run Application, args
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Using <code>ComponentScan</code> without a value results in Boot scanning for classes in the same package or any package nested within the <code>Application</code> class package.
If your GORM entities are in a different package specify the package name as the value of the <code>ComponentScan</code> annotation.
</blockquote><p class="paragraph"/>Finally create your GORM entities and ensure they are annotated with <code>grails.persistence.Entity</code>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.persistence.&#42;<p class="paragraph"/>@Entity
class Person &#123;
    <span class="java&#45;object">String</span> firstName
    <span class="java&#45;object">String</span> lastName
&#125;</pre></div>


<h2 id="standalone">2.5 GORM for Neo4j without Grails</h2>
If you wish to use GORM for Neo4j outside of a Grails application you should declare the necessary dependencies, for example in Gradle:<p class="paragraph"/><div class="code"><pre>compile <span class="java&#45;quote">"org.grails:grails&#45;datastore&#45;gorm&#45;neo4j:VERSION"</span></pre></div><p class="paragraph"/>Then annotate your entities with the <code>grails.gorm.annotation.Entity</code> annotation:<p class="paragraph"/><div class="code"><pre>@Entity
class Person &#123;
    <span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/>Then you need to place the bootstrap logic somewhere in your application which uses <code>Neo4jDataStoreSpringInitializer</code>:<p class="paragraph"/><div class="code"><pre>def initializer = <span class="java&#45;keyword">new</span> Neo4jDataStoreSpringInitializer(Person)
def applicationContext = initializer.configure()<p class="paragraph"/>println Person.count()</pre></div><p class="paragraph"/>For configuration you can either pass a map or an instance of the <code>org.springframework.core.env.PropertyResolver</code> interface:<p class="paragraph"/><div class="code"><pre>def initializer = <span class="java&#45;keyword">new</span> Neo4jDataStoreSpringInitializer(&#91;'grails.neo4j.location':'http://myserver'&#93;, Person)
def applicationContext = initializer.configure()<p class="paragraph"/>println Person.count()</pre></div><p class="paragraph"/>If you are using Spring with an existing <code>ApplicationContext</code> you can instead call <code>configureForBeanDefinitionRegistry</code> prior to refreshing the context. You can pass the Spring <code>Environment</code> object to the constructor for configuration:<p class="paragraph"/><div class="code"><pre>ApplicationContext myApplicationContext = &#8230;
def initializer = <span class="java&#45;keyword">new</span> Neo4jDataStoreSpringInitializer(myApplicationContext.getEnvironment(), Person)
initializer.configureForBeanDefinitionRegistry(myApplicationContext)<p class="paragraph"/>println Person.count()</pre></div>


<h1 id="mapping">3 Mapping domain classes to Neo4j node space</h1>
GORM for Neo4j will map each Grails domain instance to a Node in the node space. For example given the following domain class:<p class="paragraph"/>
<div class="code"><pre>class Pet &#123;
    <span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/>When an instance of <code>Pet</code> is saved:<p class="paragraph"/><div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Pet(name:<span class="java&#45;quote">"Dino"</span>)
p.save(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>Then the following Cypher CREATE is issued:<p class="paragraph"/><div class="code"><pre>CREATE (n2:Pet &#123;props&#125;)</pre></div><p class="paragraph"/>The properties of the class are converted to native Neo4j types and set as the <code>props</code> parameter to the query.<p class="paragraph"/><blockquote class="note">
If you want to see what queries GORM for Neo4j generates, enabling logging for the <code>org.grails.datastore.gorm.neo4j</code> package
</blockquote>



<h2 id="idGeneration">3.1 Neo4j ID generators</h2>
GORM by default uses a custom identity generator based on the Snowflake algorithm and stores the generated identifier in a property of each Neo4j node called <code> <em class="italic">_id_</em> </code>.<p class="paragraph"/>This has the advantage of enabling GORM to batch insert operations into a single CREATE cypher statement, hence why it is the default.<p class="paragraph"/>However, if you prefer to use native Neo4j node identifiers then you can do so by changing the generator used in the mapping:<p class="paragraph"/><div class="code"><pre>class Club &#123;<p class="paragraph"/>    &#8230;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        id generator:'<span class="java&#45;keyword">native</span>'
    &#125;<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>This will instead use the Neo4j node identifier as the object identifier with the downside being that GORM has to execute individual CREATE  statements for each new object saved, similar to the way GORM for Hibernate has to perform a SQL INSERT if the id generation strategy is an auto-increment column.<p class="paragraph"/>This disadvantage can be worked around by using the <code>saveAll</code> method to save multiple domain classes at once:<p class="paragraph"/><div class="code"><pre>Club.saveAll(&#91;
    <span class="java&#45;keyword">new</span> Club(name:<span class="java&#45;quote">"Manchester United"</span>),
    <span class="java&#45;keyword">new</span> Club(name:<span class="java&#45;quote">"Arsenal"</span>)
&#93;)</pre></div><p class="paragraph"/>If you wish to globally change id generation then you can do so in <code>grails-app/conf/application.groovy</code> (<code>Config.groovy</code> in Grails 2.x):<p class="paragraph"/>
<div class="code"><pre>grails.neo4j.<span class="java&#45;keyword">default</span>.mapping = &#123;
    id generator:'<span class="java&#45;keyword">native</span>'
&#125;</pre></div><p class="paragraph"/>In addition, if you wish to use a custom identity generation strategy you can do so by specifying a class name that implements the <code>IdGenerator</code> interface:<p class="paragraph"/><div class="code"><pre>grails.neo4j.<span class="java&#45;keyword">default</span>.mapping = &#123;
    id generator:'com.foo.MyIdGenerator'
&#125;</pre></div><p class="paragraph"/>



<h2 id="associations">3.2 Understanding Association Mapping</h2>
GORM for Neo4j will create Neo4j relationships between nodes for you based on the relationship ownership rules defined in your GORM mapping. For example the following mapping:<p class="paragraph"/><div class="code"><pre>class Owner &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> hasMany = &#91;pets:Pet&#93;
&#125;
class Pet &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> belongsTo = &#91;owner:Owner&#93;
&#125;</pre></div><p class="paragraph"/>Will generate a Cypher relationship creation query as follows:<p class="paragraph"/><div class="code"><pre>MATCH (from:Owner &#123; <em class="italic">_id_</em> :&#123;start&#125;&#125;), (to:Pet) WHERE to. <em class="italic">_id_</em>  IN &#123;end&#125; CREATE (from)&#45;&#91;r:PETS&#93;&#45;&#62;(to)</pre></div><p class="paragraph"/>As you can see from the query the relationship is defined as <code>(from)-r:PETS-&#62;(to)</code>, with the direction of the association defined by who "owns" the association. Since <code>Pet</code> defines a <code>belongTo</code> association to <code>Owner</code>, this means that <code>Owner</code> owns the association and the relationship is from <code>Owner</code> to <code>Pet</code>.<p class="paragraph"/>For more information on defining relationships with GORM, see the <a href="http://grails.github.io/grails-doc/latest/guide/GORM.html#gormAssociation" target="blank">corresponding guide in the GORM documentation</a>.



<h2 id="labelStrategy">3.3 Customizing the Label Strategy</h2>
The default strategy for defining labels is to use the class name, however the strategy to define labels for a given node is completely configurable. For example you can use static mapping to define you labels:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        labels <span class="java&#45;quote">"Person"</span>, <span class="java&#45;quote">"People"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>You can also define labels dynamically. For example:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        labels &#123; GraphPersistentEntity pe &#45;&#62; <span class="java&#45;quote">"`$&#123;pe.javaClass.name&#125;`"</span> &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>Or mix static and dynamic labels:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mapping = &#123;
    labels <span class="java&#45;quote">"People"</span>, &#123; GraphPersistentEntity pe &#45;&#62; <span class="java&#45;quote">"`$&#123;pe.javaClass.name&#125;`"</span> &#125;
&#125;</pre></div><p class="paragraph"/>At a small read/write performance cost you can define dynamic labels based on an instance:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">static</span> mapping = &#123;
    labels &#123; GraphPersistentEntity pe, instance &#45;&#62;  // 2 arguments: instance dependent label
        <span class="java&#45;quote">"`$&#123;instance.profession&#125;`"</span>
    &#125;
&#125;</pre></div>


<h2 id="schemaless">3.4 Dynamic Properties and Associations</h2>
Neo4j is a schemaless database. This means that, unlike SQL where you can only have a fixed number of rows and columns, nodes can have unlimited properties.<p class="paragraph"/> Most existing object mapping tools in statically typed languages don't allow you to harness this power, but GORM for Neo4j allows you to define both statically defined properties (ie the properties of the domain class) and domain properties.<p class="paragraph"/> For example, take the following domain class:<p class="paragraph"/> <div class="code"><pre>class Plant &#123;
    <span class="java&#45;object">String</span> name
 &#125;</pre></div><p class="paragraph"/> You can set both the statically defined <code>name</code> property, but also any arbitrary number of dynamic properties using the subscript operator in Groovy:<p class="paragraph"/>  <div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Plant(name:<span class="java&#45;quote">"Carrot"</span>)
  p&#91;'goesInPatch'&#93; = <span class="java&#45;keyword">true</span>
  p.save(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>  Any simple properties can be included, however if you wish to have dynamic associations you can as well by modifying the mapping:<p class="paragraph"/> <div class="code"><pre>class Plant &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> mapping = &#123;
        dynamicAssociations <span class="java&#45;keyword">true</span>
    &#125;
 &#125;</pre></div><p class="paragraph"/> With this in place you can define dynamic associations:<p class="paragraph"/>  <div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Plant(name:<span class="java&#45;quote">"Carrot"</span>)
  p&#91;'related'&#93; = &#91; <span class="java&#45;keyword">new</span> Plant(name:<span class="java&#45;quote">"Potato"</span>).save() &#93;
  p.save(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>  The downside of dynamic associations is that GORM has to issue a separate query for each loaded instance when retrieving entities. If you have a small amount of data this is not a problem, but for larger data sets it is not recommended.<p class="paragraph"/><p class="paragraph"/>



<h1 id="querying">4 Querying with GORM for Neo4j</h1>
GORM for Neo4j supports all the different querying methods provided by GORM including:
<ul class="star">
<li><a href="http://grails.github.io/grails-doc/latest/guide/GORM.html#finders" target="blank">Dynamic Finders</a></li>
<li><a href="http://grails.github.io/grails-doc/latest/guide/GORM.html#whereQueries" target="blank">Where Queries</a></li>
<li><a href="http://grails.github.io/grails-doc/latest/guide/GORM.html#criteria" target="blank">Criteria Queries</a></li>
</ul><p class="paragraph"/>However, HQL queries are not supported, instead you can use Cypher directly if you so choose.<p class="paragraph"/><blockquote class="note">
If you want to see what queries GORM for Neo4j generates, enabling logging for the <code>org.grails.datastore.gorm.neo4j</code> package
</blockquote>



<h2 id="lazyLoading">4.1 Understanding Lazy Loading</h2>
When retrieving a GORM entity and its associations by default single-ended associations will only retrieve the association id, whilst associations to many objects will not retrieve the association at all until it is accessed. This is called lazy loading.<p class="paragraph"/>For example given the following domain model:<p class="paragraph"/><div class="code"><pre>class League &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> hasMany = &#91;clubs:Club&#93;
&#125;
class Club &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> belongsTo = &#91;league:League&#93;
    <span class="java&#45;keyword">static</span> hasMany = &#91;teams: Team &#93;
&#125;
class Team  &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> belongsTo = &#91;club:Club&#93;
&#125;</pre></div><p class="paragraph"/>When you retrieve the <code>Club</code> by name:<p class="paragraph"/><div class="code"><pre>def club = Club.findByName(<span class="java&#45;quote">"Manchester United"</span>)</pre></div><p class="paragraph"/>You will get the following Cypher query:<p class="paragraph"/><div class="code"><pre>MATCH (n:Club) WHERE ( n. <em class="italic">_id_</em> =&#123;1&#125; )
OPTIONAL MATCH(n)&#45;&#91;:LEAGUE&#93;&#45;&#62;(leagueNode)
RETURN n as data, collect(DISTINCT leagueNode. <em class="italic">_id_</em> ) as leagueIds</pre></div><p class="paragraph"/>As you can see the <code>teams</code> association is not loaded in the query, and only the ID of the <code>league</code> association is retrieved. If you then iterate over the teams you will get a second query to obtain the teams:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">for</span>(team in club.teams) &#123;
    println team.name
&#125;</pre></div><p class="paragraph"/>The query generated will be:<p class="paragraph"/><div class="code"><pre>MATCH (from:Club)&#60;&#45;&#91;:CLUB&#93;&#45;(to:Team) WHERE from. <em class="italic">_id_</em>  = &#123;id&#125; RETURN to as data</pre></div><p class="paragraph"/>If you wish to avoid this secondary query to retrieve the data you can do so using an eager query:<p class="paragraph"/><div class="code"><pre>// using a dynamic finder
def club = Club.findByName(<span class="java&#45;quote">"Manchester United"</span>, &#91;fetch:&#91;teams:'join'&#93;&#93;)<p class="paragraph"/>// using a where queries
def query = Club.where &#123; name == <span class="java&#45;quote">"Manchester United"</span> &#125;
                .join('teams')
def club = query.find()<p class="paragraph"/>// using criteria
def query = Club.createCriteria()
def club = query.get &#123;
    eq 'name', <span class="java&#45;quote">"Manchester United"</span>
    join 'teams'
&#125;</pre></div><p class="paragraph"/>
This will instead generate the following query:<p class="paragraph"/><div class="code"><pre>MATCH (n:Club) WHERE ( n.name=&#123;1&#125; )
OPTIONAL MATCH(n)&#60;&#45;&#91;:CLUB&#93;&#45;(teamsNode)
OPTIONAL MATCH(n)&#45;&#91;:LEAGUE&#93;&#45;&#62;(leagueNode)
RETURN n as data, collect(DISTINCT leagueNode. <em class="italic">_id_</em> ) as leagueIds, collect(DISTINCT teamsNode) as teamsNodes</pre></div><p class="paragraph"/>As you can see the associated team nodes are loaded by the query. If you prefer this to happen for every query, then this can also be configured in the mapping:<p class="paragraph"/><div class="code"><pre>class Club &#123;
    ...<p class="paragraph"/>    <span class="java&#45;keyword">static</span> mapping = &#123;
       teams fetch:<span class="java&#45;quote">"eager"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>You can also configure the collection ids to be eagerly loaded, but the instances themselves to be lazy loaded via proxies:<p class="paragraph"/><div class="code"><pre>class Club &#123;
    ...<p class="paragraph"/>    <span class="java&#45;keyword">static</span> mapping = &#123;
       teams fetch:<span class="java&#45;quote">"eager"</span>, lazy:<span class="java&#45;keyword">true</span>
    &#125;
&#125;</pre></div>


<h2 id="cypher">4.2 Querying with Cypher</h2>
To query with raw Cypher queries you can use the built in <code>find</code> and <code>findAll</code> methods:<p class="paragraph"/> <div class="code"><pre>def club = Club.find(<span class="java&#45;quote">"MATCH n where n.name = &#123;1&#125; RETURN n"</span>, 'FC Bayern Muenchen')
 def clubs = Club.findAll(<span class="java&#45;quote">"MATCH n where n.name = &#123;1&#125; RETURN n"</span>, 'FC Bayern Muenchen')</pre></div><p class="paragraph"/> Note that the first returned item should be the node itself. To execute cypher queries and work with the raw results use <code>cypherStatic</code>:<p class="paragraph"/> <div class="code"><pre>Result result = Club.cypherStatic(<span class="java&#45;quote">"MATCH n where n.name = &#123;1&#125; RETURN n"</span>, 'FC Bayern Muenchen')</pre></div><p class="paragraph"/> When working with raw results, you can convert any <code>org.neo4j.graphdb.Node</code> into a domain instance using the <code>as</code> keyword:<p class="paragraph"/> <div class="code"><pre>Node myNode = &#8230;
 Club club = myNode as Club</pre></div><p class="paragraph"/> You can also convert any <code>org.neo4j.graphdb.Result</code> instance to a list of domain classes:<p class="paragraph"/> <div class="code"><pre>Result result = &#8230;
  List&#60;Club&#62; clubs = result.toList(Club)</pre></div><p class="paragraph"/>


<h2 id="indexing">4.3 Defining the Query Index</h2>
To define which properties of your domain class should be indexed for querying you can do so in the mapping:<p class="paragraph"/><div class="code"><pre>class Club &#123;
    <span class="java&#45;object">String</span> name<p class="paragraph"/>    &#8230;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        name index:<span class="java&#45;keyword">true</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>On startup GORM will use Cypher to create indexes as follows:<p class="paragraph"/><div class="code"><pre>CREATE INDEX ON :Club(name)</pre></div><p class="paragraph"/>To define a unique index use <code>unique</code> instead:<p class="paragraph"/><div class="code"><pre>class Club &#123;
    <span class="java&#45;object">String</span> name<p class="paragraph"/>    &#8230;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        name unique:<span class="java&#45;keyword">true</span>
    &#125;
&#125;</pre></div>



<h1 id="neo4jEnhancements">5 Enhancements to Neo4j core API</h1>
Neo4j Grails contains some enhancements to the Neo4j core API.<p class="paragraph"/><h4>Setting properties on nodes/relationships</h4><p class="paragraph"/>Assigning an arbitrary property onto a Neo4j node or relationship can be simply done by using Groovy's property
mechanism:
<div class="code"><pre>def node = graphDatabaseService.createNode()
node.myProperty = myValue</pre></div><p class="paragraph"/>The same applies for getting properties:<p class="paragraph"/><div class="code"><pre>def node = &#8230;
def value = node.myProperty</pre></div><p class="paragraph"/>

                    </div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Additional Gorm Methods</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="../ref/Additional%20Gorm%20Methods/cypher.html">cypher</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Additional%20Gorm%20Methods/cypherStatic.html">cypherStatic</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Additional%20Gorm%20Methods/schemaless%20attributes.html">schemaless attributes</a>
                        </div>
                        
                        </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Beans</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="../ref/Beans/graphDatabaseService.html">graphDatabaseService</a>
                        </div>
                        
                        </div>
                    </div>
                    
                </div>
            </div>
        </td>
            </tr>
        </table>

        <div id="footer">
            
            
        </div>



<script type="text/javascript" src="../js/docs.js"></script>

    </body>
</html>
